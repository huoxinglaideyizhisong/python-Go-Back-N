# 前言
Go-Back-N，后退N帧协议，是数据链路层为了实现流量控制的一种协议。相关协议还有stop-and-wait、selective-repeat等。具体原理本文不赘述。本次实验将用python模拟Go-Back-N协议。
# 实验要求
本次实验要求采用 GBN（Go-Back-N）协议实现可靠的文件传输。利用UDP socket模仿模拟并实现 PDU (协议数据单元, Protocol Data Unit)的发送和接收，每个 UDP 数据报封装一个PDU。需要自己定义PDU结构。所实现的 GBN 协议应支持全双工，实现双向文件传输。允许根据配置文件中给出的百分比随机产生 PDU错误和 PDU 丢失。

# 设计思路
为了实现不同主机之间的文件发送，我打算利用一个server实现消息中转。主机先把PDU发送给server，然后server根据PDU帧头部的信息（附加了发送方、接收方的地址）把PDU转发给对应的接收方。
实际上server就是起了一个类似交换机的作用。
为什么一定要用server？我想的是server可以认为是一个全局管理员，拥有上帝视角。这样可以方便地分析用户之间传输的数据帧，后续debug也比较容易。此外，万一用户不在线，还能起到一个暂存文件的作用。

server端应该实现的功能：
1. 解析PDU数据帧，提取出头部，分析发送方和接收方的地址和端口。
2. 维护用户的ip地址表，根据表格转发PDU数据帧。

client端应该实现的功能：
1. 根据GBN协议，维护发送窗口。根据发送方的地址，封装好PDU数据帧头部和PDU数据帧。根据数据生成checksum。发送PDU给server。
2. 根据GBN协议，维护接收窗口。收到PDU数据帧后，提取出头部信息，检查序号是否正确，并检查数据是否出错。
3. 如果数据出错，则丢弃帧。如果数据没出错但是序号不对，也丢弃。如果都没错，则正常接收，并向发送方返回ack帧。
4. 正确识别接收方的ack帧，维护自己的窗口。

此外，还需自定义PDU帧结构。为此，定义两个类MyPDUHeader和MyPDU。
MyPDUHeader应该实现的功能：
1. 按照传入的参数，封装好头部，转化为byte。
2. 对传来的一串raw byte，解码数据流，得到头部各参数。

MyPDU应该实现的功能：
1. 将header和数据一起封装为帧。

整个项目的框架大致如下：
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/f1b15aefad6849b1a7d4f2b2aded1e59.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/5bca62cea9c64290816a9b5e48805292.png)

 # 具体实现
 ## 自定义PDU结构

为了让通信双方能成功解析帧结构，必须定义一个规范的、清晰的帧结构。我定义的帧结构如下：
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/486eaf7906934d40bbb5cd3378e9c90e.png)
参数说明：

-	`Header_length`: 帧头部长度，在我的定义中为24字节长，占2字节。
-	`Data_length`: 数据部分长度，2字节，2字节可能太小了，但本实验的数据量比较小，就没有设置得很大。
-	`Check_sum`:使用CRC校验data计算出来的校验码。
-	`Source_Ip`: 发送方的IP地址，4个字节。
-	`Source_port`: 发送方的端口号，2个字节。
-	`Dest_Ip、Dest_port`：接收方的ip和端口号
-	`Type`：指明本帧是数据帧还是ack帧，或者结束帧，占2个字节。
-	`Seq_num`：序列号，表明本帧是第几个数据帧。事实上根据GBN协议，用n位bit对帧序号进行编号，根本用不到4个字节，我纯粹是因为强迫症，想把头部占满四排才设这么大。
-	`Data`：数据部分，最大长度为配置文件中的`DataSize`。

如果还有其他需要，可以修改头部。

## 校验
采用常用的crc（循环冗余）校验，由于数据量比较大，一个一个字节地算比较慢，查了资料，用查表法效率更高。我数学不好，查表法的原理看不懂，照着c语言版本改成了python版。

## 发送方和接收方
在GBN协议中，发送方需要维护一个大小为SWSize的窗口
![在这里插入图片描述](https://img-blog.csdnimg.cn/7b1d245f1d964848abc33116d16a76ae.png)
具体地，发送方需要维护的变量：`next_frame_to_send`，指向下一个可以发送的帧的序号，在上图中对应白色部分。`ack_expected`，指向第一个已经发送但是没有收到确认的帧，对应图中橙色部分。如果发送方收到了接收方的ack帧，需要及时将窗口向右滑动。

对于接收方，在收到发送方的数据帧时，需要检查crc校验码。接收方首先提取出头部和数据部分，根据数据部分计算出crc16校验码，然后与头部的crc校验码比较，如果一致，则crc校验正确。如果不正确，则丢弃该帧。这样就解决了发送方帧可能错误的问题。此外，由于接收方的窗口大小始终为1，还要比较头部的帧序号和自己的`frame_expected`变量一不一样，如果不一样，则序号出错，直接丢弃该帧。这样就解决了发送方帧可能丢失的问题。
在本次实验中，我采用的ack是累积确认，如果发出的ack是ack n，则代表序号为n之前的帧都被成功接收，发送方下一个需要发送的帧序号是n。
接收方在每次发送一个帧后，都应该维护对应序号的计时器。如果某一个帧的计时器超时了，则应该设置`next_frame_to_send`=该帧序号，即该帧之后的帧都应该重新发送。如果需要重新发送，则可能是因为之前发送的帧丢失了或者损坏了，此时接收方会丢弃帧，这种情况下只能重发。也可能是因为接收方的ack超时或者丢失了，此时重发一遍也没有影响，因为接收方会把相应帧丢弃。具体地，利用python内置的time库实现定时器的功能。

# 开发环境
- 操作系统：windows10
- 编程语言：python，版本：python 3.9.7
- 使用到的库（libraries）：sokcet（UDP编程）、time（计时器实现）、_thread、threading（多线程、互斥锁）、random（模拟错误和丢包）、sys、os（退出系统、管理文件夹等）。


# 编程实现
![在这里插入图片描述](https://img-blog.csdnimg.cn/7c305516933f4f969ffacb39464a5718.png)
## 文件说明

- `analysis.py`：日志分析文件，可以得到总共传输多少帧、乱序帧占比、错误帧占比、消耗时间等。需要修改代码中日志文件的路径

- `my_client.py`：客户端的实现，封装好了MyClient类
- `my_config.py`：配置文件，包含了许多超参数和全局信息
- `my_crc.py`：基于crc16查表法的python实现，我数学不好，看不懂原理，照着c语言版本改的
- `my_PDU.py`：Protocol Data Unit，PDU，协议数据单元。封装好了MyPDUHeader和MyPDU两个类，客户端之间数据交流的单位
- `my_server.py`：服务器的实现，它就是起一个类似交换机的功能，中转PDU
- `my_timer.py`：定时器类。
- `start_client.py`：由此文件开启客户端。由于是在自己电脑上测试，建议ip地址都使用`127.0.0.x`的形式，`127.0.0.1`已经被服务器使用。
- `start_server.py`：由此文件开启服务器。服务器的ip地址默认为127.0.0.1
- `data`：存放了所有用户的文件，以他们的ip地址分类成一个个子文件夹。

## 使用方法
先开启服务器端，进入项目文件夹，在命令行输入：

```python
python start_server.py
```

然后开启客户端。客户端之间可以相互发送文件。

```python
python start_client.py
```

# 注意事项

大文件发送时间较长，我目前只尝试了9MB的文件。不知道更大的文件会不会出bug。

个人代码水平有限，我也是调试了好几天才勉强凑出一个可运行的玩意儿，前前后后熬了许久的夜，身心交瘁。

小白编程练习，代码简陋不堪，欢迎大家批评指正。

同时也希望可以给没思路的同学们一个思路。

# 演示

https://www.bilibili.com/video/BV1wX4y127wu/

# 缺点与展望

- 虽然说双方可以互相发送文件，但是发送时就只能发送，接收时就只能接收，能否同时发送和接收？
- 代码能力有限，调试过程中可能会出现bug。
- 能否做成用户界面GUI？目前的程序还是在命令行运行，不太方便。如果能做出用户界面就好了。
- 能否上传本地文件？目前发送一个文件，必须要把此文件传入`data`下自己目录下，非常不方便，如果能传入本地路径就更好了。当然这个实现很简单，稍微修改一下代码就行。此外，如果能将这一点与GUI结合，能与操作系统交互就更好了。
- 客户端的实现过于简陋，它只是起到一个类似交换机的作用，傻乎乎地转发数据帧。如果能实现更多功能，如分析全局信息、看到用户是否在线等就更好了。做出一个GUI更好
- 说不定可以用多个客户端模拟局域网多交换机。
- 目前发送文件，必须双方都在线才行。如果客户端能起到数据暂存作用就好了，当用户不在线，就暂存数据，如果上线了，再把文件发给他。

# 项目文件

github网址：
https://github.com/huoxinglaideyizhisong/python-Go-Back-N
